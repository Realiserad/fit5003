\documentclass{article}
\usepackage[utf8]{inputenc}

\begin{document}
\textbf{What are the suggested authentication guidelines in OWASP "Authentication Cheat Sheet"?}
\begin{enumerate}
    \item Usernames should not be case sensitive and possibly autogenerated.
    \item Passwords policy should be enforced.
    \item Implement secure password recovery (preferably by sending a time-limited token on a side-channel, e.g by email)
    \item Store passwords securely (see next question).
    \item Only transmit passwords over TLS
    \item Require re-authentication for sensitive features.
    \item Consider 2-factor authentication when a user performs sensitive operations (e.g OTP-codes, email tokens ect).
    \item Generic error messages
    \item Prevent brute-force attempts, e.g by limiting the number of login attempts
    \item Log and monitor authentication attempts
\end{enumerate}

\textbf{What are the guidelines provided in OWASP "Password storage cheat sheet"?}
\begin{enumerate}
    \item Use a 32-bits or 64-bits salt generated by a cryptographically secure PRNG.
    \item Use Argon2 or scrypt to store the password.
    \item Prepare for the database being compromised by being able to lock down and change parameters for the protection function such as salt and work factor.
\end{enumerate}
\textbf{What is the purpose of salt and should it be kept a secret?}\\
The purpose of salt is to prevent the use of rainbow tables, or precomputed hashtables. Using a unique salt for each user also prevents an attacker from detecting and recovering common passwords. 

The idea is that a salt will ensure that even if two users have the same password, they will still have different hashes (since they use a different salt). That means, if an attacker cracks a password, she will not be able to see (by looking at the hashes) which user has the same password.

The salt fills it purpose without being a secret, so it can be stored together with the password.
\newline
\textbf{What is the purpose of iteration count?}\\
Iteration count is used in for example PBKDF2 to make the function slower. The slower the password hashing function, the better, since it will take a longer time for the attacker to crack passwords using a brute-force attack.
\newline
\textbf{How does key-derivation in RFC2898 work?}\
\begin{verbatim}
PBKDF2(P, S, c, dkLen)
    PRF_init(P || S || i);
    byte DK[dkLen];
    // hLen is the number of bytes in the PRNG output
    l = dkLen / hLen;
    for i = 0; i < dkLen; i += l
        word W = F(P, S, c, i);
        fill the next l bytes in DK with W
    return DK;
    
F(P, S, c, i)
    word w = 0; // has length hLen
    repeat c times
        w ^= PRF_next();
    return w;

PBKDF2(P, S, c, dkLen)
    byte DK[dkLen]
    // H is either MD5 or SHA1
    DK = H(P || S); 
    for i = 0; i < c; i++
        DK = H(DK)
    return DK;
\end{verbatim}
\textbf{What are the possible uses of password based cryptography?}\\
Derive a cryptographic key from a password. It can be used by FDE software to create the key for decryption/encryption on boot, by letting the user input a password.
\\
\textbf{According to RFC 2898, what is the recommended way of creating a salt when a PRNG is not available?}
\newline
RFC 2898 recommends that you use a key-derivation function of the password concatenated with the message to be processed, i.e \verb!PBKDF2(P || M)!.
\newline
\textbf{List a few symmetric encryption algorithms and modes of operation.}
\begin{verbatim}
    > openssl
     > ciphers
     (Output goes here)
\end{verbatim}
Some modes of operation are Electronic Codebook Mode (ECB) where each block is encrypted independently. The problem with this approach is that the same plaintext will yield the same ciphertext every time it is encrypted. Another mode is Counter Mode (CTR) where the an initialization vector (IV) is used. The IV and a counter is combined into a block which is encrypted and XORed with the plaintext. The counter is incremented and the process is repeated for all plaintext blocks which needs to be encrypted. The advantage of CTR mode is that if one block is lost in transmission only one block will be lost in the decryption. A third mode of operation, which is commonly used today is Cipher Block Chaining (CBC). In cipher block chaining you XOR the previous encrypted block with the plaintext before encryption. The first "encrypted" block is the IV. The mode used with AES in TLSv2 is Galois Counter Mode (GCM).
\newline
\textbf{List a few other cryptographic libraries.}
\begin{enumerate}
    \item Polar SSL
    \item Mozilla's Network Security Services
\end{enumerate}

\end{document}
